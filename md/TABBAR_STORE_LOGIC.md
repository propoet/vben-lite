# Tabbar Store 逻辑详解

## 概述

Tabbar Store 是 Vben 框架中用于管理多标签页（Tabs）功能的核心状态管理模块。它负责管理所有打开的标签页、标签页的缓存状态、标签页的固定、排序、刷新等功能。

## 核心功能

Tabbar Store 提供以下核心功能：

1. **标签页管理**：添加、删除、更新标签页
2. **标签页缓存**：管理哪些组件需要被 keep-alive 缓存
3. **标签页固定**：支持固定标签页，固定标签页不能关闭且排在前面
4. **标签页排序**：支持拖拽排序标签页
5. **标签页刷新**：支持刷新单个或多个标签页
6. **批量操作**：关闭左侧、右侧、其他、所有标签页
7. **标签页标题**：支持静态和动态标题设置

## 状态结构

### 主要状态字段

**tabs**：存储所有打开的标签页列表。每个标签页包含路由的完整信息，如路径、参数、查询参数、元信息等。

**cachedTabs**：使用 Set 数据结构存储需要缓存的组件名称。这个集合用于 keep-alive 组件的 include 属性，决定哪些组件需要被缓存。

**excludeCachedTabs**：使用 Set 数据结构存储需要临时排除缓存的组件名称。这个集合用于 keep-alive 组件的 exclude 属性，主要用于刷新功能。

**dragEndIndex**：记录拖拽结束时的索引位置，用于标签页拖拽排序功能。

**menuList**：定义标签页右键菜单的选项列表，包括关闭、固定、最大化、刷新、新窗口打开、关闭左侧、关闭右侧、关闭其他、关闭所有等选项。

**renderRouteView**：布尔值，控制路由视图是否渲染。用于刷新功能，通过隐藏和显示视图来触发组件重新渲染。

**updateTime**：时间戳，用于触发更新。由于深度监听整个 tabs 数组会损耗性能，所以使用更新时间戳的方式来触发依赖该状态的组件更新。

### 持久化策略

**tabs** 字段会被持久化到 sessionStorage 中。这意味着当用户刷新页面时，之前打开的标签页会被恢复。使用 sessionStorage 而不是 localStorage 的原因是，标签页状态是会话级别的，关闭浏览器标签页后应该清除。

其他字段（如 cachedTabs、excludeCachedTabs 等）不会被持久化，每次页面刷新后都会重新初始化。

## 核心方法详解

### 添加标签页（addTab）

这是标签页管理的核心方法，负责添加或更新标签页。

**工作流程**：

1. **克隆标签页对象**：首先对传入的路由标签页对象进行深拷贝，避免直接修改原始路由对象。

2. **生成唯一标识**：如果标签页没有 key，会根据路由信息自动生成。key 的生成规则是：优先使用查询参数中的 pageKey，如果没有则根据 meta 中的 fullPathKey 决定使用 path 还是 fullPath。

3. **检查是否显示**：判断标签页是否应该显示。如果标签页或其父级路由设置了 hideInTab 为 true，则不会添加到标签页列表中。

4. **查找是否已存在**：通过比较 key 来判断标签页是否已经存在。

5. **处理已存在的情况**：如果标签页已存在，不会重复添加，而是更新标签页的信息。更新时会合并路由参数、查询参数、元信息等，但会保留固定标签页属性和自定义标题属性。

6. **处理新标签页的情况**：如果标签页不存在，需要添加新标签页。但在添加前需要检查两个限制：
   - **动态路由打开数限制**：如果路由的 meta 中设置了 maxNumOfOpenTab，且该路由的同名标签页数量已达到限制，则关闭最早打开的同名标签页。
   - **全局标签页数量限制**：如果配置中设置了 maxCount，且当前标签页数量已达到限制，则关闭第一个非固定标签页。

7. **更新缓存**：添加或更新标签页后，会调用 updateCacheTabs 方法更新缓存列表。

### 关闭标签页（closeTab）

关闭标签页的逻辑需要考虑多种情况。

**工作流程**：

1. **判断是否当前激活标签页**：通过比较标签页的 key 和当前路由的 key 来判断。

2. **关闭非激活标签页**：如果关闭的不是当前激活的标签页，直接关闭即可，无需跳转。

3. **关闭激活标签页**：如果关闭的是当前激活的标签页，需要跳转到其他标签页。跳转规则是：
   - 优先跳转到下一个标签页（如果存在）
   - 如果没有下一个，则跳转到上一个标签页（如果存在）
   - 如果既没有下一个也没有上一个，说明这是最后一个标签页，会输出错误信息

4. **更新缓存**：关闭标签页后更新缓存列表。

### 批量关闭操作

提供了多种批量关闭标签页的方法：

**关闭左侧标签页（closeLeftTabs）**：
- 找到参考标签页在列表中的位置
- 获取该位置左侧的所有标签页
- 过滤出非固定标签页
- 批量关闭这些标签页

**关闭右侧标签页（closeRightTabs）**：
- 找到参考标签页在列表中的位置
- 获取该位置右侧的所有标签页
- 过滤出非固定标签页
- 批量关闭这些标签页

**关闭其他标签页（closeOtherTabs）**：
- 获取所有标签页的 key
- 过滤出除了参考标签页外的所有标签页
- 过滤出非固定标签页
- 批量关闭这些标签页

**关闭所有标签页（closeAllTabs）**：
- 保留所有固定标签页
- 如果没有固定标签页，则保留第一个标签页
- 关闭其他所有标签页
- 跳转到默认标签页（第一个标签页）

所有批量关闭操作都会保护固定标签页，固定标签页不会被关闭。

### 固定标签页（pinTab）

固定标签页功能允许用户将重要标签页固定在前面，且不能关闭。

**工作流程**：

1. **查找标签页位置**：在标签页列表中找到要固定的标签页。

2. **设置固定属性**：将标签页的 meta.affixTab 设置为 true。

3. **保留原有标题**：保留标签页的原有标题。

4. **重新排序**：固定标签页需要移动到固定标签页区域。具体做法是：
   - 过滤出所有固定标签页
   - 找到当前标签页在固定标签页中的新位置
   - 通过 sortTabs 方法将标签页移动到新位置

固定标签页会按照 affixTabOrder 属性排序，如果没有设置则按默认顺序。

### 取消固定标签页（unpinTab）

取消固定标签页的逻辑与固定相反。

**工作流程**：

1. **查找标签页位置**：在标签页列表中找到要取消固定的标签页。

2. **设置非固定属性**：将标签页的 meta.affixTab 设置为 false。

3. **移动到非固定区域**：取消固定后，标签页需要移动到非固定标签页区域。新位置是固定标签页区域的末尾，也就是非固定标签页区域的开始位置。

4. **重新排序**：通过 sortTabs 方法将标签页移动到新位置。

### 标签页排序（sortTabs）

支持通过拖拽改变标签页的顺序。

**工作流程**：

1. **获取要移动的标签页**：根据原索引获取标签页对象。

2. **移除原位置**：从原索引位置移除标签页。

3. **插入新位置**：在新索引位置插入标签页。

4. **更新拖拽索引**：增加 dragEndIndex 的值，用于触发依赖该值的组件更新。

### 标签页刷新（refresh）

刷新功能允许用户重新加载标签页内容，而不需要关闭后重新打开。

**刷新原理**：

刷新功能通过控制 keep-alive 的缓存来实现。当需要刷新时：

1. **排除缓存**：将要刷新的组件名称添加到 excludeCachedTabs 集合中，这样 keep-alive 会临时排除该组件的缓存。

2. **隐藏视图**：将 renderRouteView 设置为 false，隐藏路由视图。

3. **显示进度条**：调用 startProgress 显示加载进度条，给用户反馈。

4. **等待时间**：等待 200 毫秒，确保视图完全隐藏。

5. **恢复缓存**：从 excludeCachedTabs 中移除组件名称，恢复缓存。

6. **显示视图**：将 renderRouteView 设置为 true，显示路由视图。

7. **隐藏进度条**：调用 stopProgress 隐藏加载进度条。

通过这种方式，组件会被强制重新渲染，实现刷新效果。

**刷新当前标签页**：如果传入的是 Router 实例，会根据当前路由刷新对应的标签页。

**刷新指定标签页**：如果传入的是路由名称字符串，会刷新指定名称的标签页。注意：不能是当前路由名称，否则不会刷新。

### 更新缓存（updateCacheTabs）

这个方法负责根据当前打开的标签页更新需要缓存的组件列表。

**缓存规则**：

1. **只缓存设置了 keepAlive 的标签页**：只有标签页的 meta.keepAlive 为 true 时，才会被缓存。

2. **缓存标签页本身**：标签页对应的组件名称会被添加到缓存列表。

3. **缓存父级路由组件**：标签页的所有父级路由组件也会被缓存。这是因为 Vue Router 的嵌套路由结构中，父级组件也需要被缓存才能保持子组件的状态。

**使用场景**：

这个方法返回的缓存列表会用于 keep-alive 组件的 include 属性，确保需要缓存的组件被正确缓存，不需要缓存的组件不被缓存，从而优化性能和用户体验。

### 标签页标题管理

支持两种标题设置方式：

**静态标题**：直接设置字符串作为标题。

**动态标题**：设置计算属性（ComputedRef）作为标题。当计算属性的值变化时，标签页标题会自动更新。这适用于需要根据状态或多语言动态更新标题的场景。

**设置标题（setTabTitle）**：设置标签页的自定义标题。如果标签页已存在，会更新其 newTabTitle 属性。

**重置标题（resetTabTitle）**：清除标签页的自定义标题，恢复为默认标题（从路由 meta.title 获取）。

## 辅助函数

### 标签页 Key 生成（getTabKey）

标签页的 key 是唯一标识符，用于区分不同的标签页。

**生成规则**（按优先级）：

1. **使用 pageKey**：如果路由的查询参数中有 pageKey，优先使用 pageKey 作为 key。这允许通过查询参数手动指定标签页的唯一标识。

2. **使用 path**：如果路由的 meta 中 fullPathKey 为 false，使用 path 作为 key。这适用于不需要区分查询参数的场景。

3. **使用 fullPath**：默认情况下使用 fullPath（包含路径、查询参数、哈希）作为 key。这能确保相同路径但不同参数的路由被识别为不同的标签页。

生成 key 时会尝试解码 URI 编码，如果解码失败则使用原始值。

### 标签页比较（equalTab）

通过比较两个标签页的 key 来判断它们是否相同。这用于查找标签页、判断标签页是否已存在等场景。

### 标签页克隆（cloneTab）

深拷贝标签页对象，避免直接修改原始路由对象。克隆时会保留路由的基本信息（路径、参数、查询参数等）和元信息，特别是会保留自定义标题。

### 判断是否固定（isAffixTab）

检查标签页的 meta.affixTab 属性，判断标签页是否被固定。

### 判断是否显示（isTabShown）

判断标签页是否应该在标签页栏中显示。如果标签页本身或其任何父级路由设置了 hideInTab 为 true，则不会显示。

## 计算属性（Getters）

### 固定标签页列表（affixTabs）

返回所有固定标签页，并按照 affixTabOrder 属性排序。如果没有设置 affixTabOrder，则按默认顺序。

### 所有标签页列表（getTabs）

返回所有标签页，固定标签页排在前面，非固定标签页排在后面。这个顺序是标签页栏显示的顺序。

### 缓存列表（getCachedTabs）

返回需要缓存的组件名称数组，用于 keep-alive 的 include 属性。

### 排除缓存列表（getExcludeCachedTabs）

返回需要排除缓存的组件名称数组，用于 keep-alive 的 exclude 属性。主要用于刷新功能。

## 使用场景

### 路由切换时自动添加标签页

在路由守卫中，当路由切换时，会自动调用 addTab 方法添加标签页。如果标签页已存在，则更新标签页信息（如参数、查询参数等）。

### 标签页栏显示

标签页栏组件通过 getTabs getter 获取标签页列表，按照固定标签页在前、非固定标签页在后的顺序显示。

### 标签页右键菜单

右键菜单通过 menuList 获取可用的菜单选项，根据选项调用相应的方法（如关闭、固定、刷新等）。

### 标签页拖拽排序

当用户拖拽标签页时，会调用 sortTabs 方法改变标签页的顺序。拖拽结束后，dragEndIndex 会增加，用于触发相关组件的更新。

### Keep-Alive 缓存管理

路由视图组件通过 getCachedTabs 和 getExcludeCachedTabs 获取缓存配置，传递给 keep-alive 组件，实现组件的缓存和刷新功能。

### 标签页关闭时的路由跳转

当关闭当前激活的标签页时，会自动跳转到相邻的标签页，确保用户始终有一个可见的页面。

### 标签页数量限制

通过配置 maxCount 可以限制同时打开的标签页数量。当超过限制时，会自动关闭最早打开的非固定标签页。

### 动态路由数量限制

对于动态路由（如详情页），可以通过 meta.maxNumOfOpenTab 限制同一路由的打开数量。当超过限制时，会自动关闭最早打开的同名标签页。

## 工作原理

### 标签页唯一标识

每个标签页都有一个唯一的 key，这个 key 用于区分不同的标签页。即使路径相同，如果查询参数不同，也会被视为不同的标签页。

### 标签页状态同步

标签页的状态与路由状态是同步的。当路由切换时，标签页会自动更新。当标签页关闭时，路由也会相应跳转。

### 缓存机制

标签页的缓存机制依赖于 Vue 的 keep-alive 组件。通过动态设置 include 和 exclude 属性，控制哪些组件需要缓存，哪些组件需要排除缓存。

### 刷新机制

刷新功能通过临时排除缓存来实现。当需要刷新时，将组件从缓存中排除，隐藏视图，然后恢复缓存和视图，强制组件重新渲染。

### 固定标签页机制

固定标签页通过 meta.affixTab 属性标识。固定标签页不能被关闭，且会排在标签页列表的前面。固定标签页可以按照 affixTabOrder 排序。

### 性能优化

使用 updateTime 时间戳而不是深度监听整个 tabs 数组，避免性能损耗。当需要触发更新时，只需更新 updateTime 的值即可。

## 与其他模块的协作

### 与路由系统

标签页 Store 与 Vue Router 紧密集成。路由切换时会自动添加标签页，标签页关闭时会跳转路由。

### 与 Keep-Alive 组件

通过提供缓存列表和排除缓存列表，控制 keep-alive 组件的缓存行为。

### 与 Preferences 配置

标签页的最大数量限制（maxCount）等配置来自 Preferences 系统。

### 与工具函数

使用 openRouteInNewWindow 在新窗口打开路由，使用 startProgress 和 stopProgress 显示加载进度。

## 注意事项

### 固定标签页保护

所有关闭操作都会保护固定标签页，固定标签页不会被关闭。这是通过 isAffixTab 函数判断的。

### 标签页数量限制

当标签页数量超过限制时，会自动关闭最早打开的非固定标签页。这确保了标签页数量不会无限增长。

### 动态路由限制

对于动态路由，可以通过 maxNumOfOpenTab 限制同一路由的打开数量，避免打开过多相同类型的页面。

### 缓存更新时机

每次添加、删除、更新标签页后，都会调用 updateCacheTabs 更新缓存列表，确保缓存状态与标签页状态一致。

### 刷新功能的限制

刷新功能只能刷新非当前标签页。如果要刷新当前标签页，需要先切换到其他标签页，然后再刷新。

### 标签页显示控制

通过 hideInTab 属性可以控制标签页是否显示。如果标签页或其父级路由设置了 hideInTab，则不会在标签页栏中显示。

## 总结

Tabbar Store 是一个功能完整、设计精良的标签页管理系统。它通过状态管理、缓存控制、路由同步等机制，实现了多标签页的所有核心功能。其设计考虑了性能优化、用户体验、扩展性等多个方面，是一个值得学习和参考的实现。
